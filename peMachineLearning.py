# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwindow.ui'
#
# Created by: PyQt5 UI code generator 5.7
#
# WARNING! All changes made in this file will be lost!
import sys
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QTableWidgetItem
from PyQt5 import QtCore, QtWidgets
from PEFile import PE32

from numpy import genfromtxt
import numpy as np
import os
import csv
from sklearn.decomposition import PCA, NMF
from sklearn.cluster import KMeans
from sklearn.cluster import MeanShift, estimate_bandwidth
from sklearn.metrics import silhouette_samples, silhouette_score
import matplotlib.cm as cm
from mainwindow import Ui_MainWindow
files = []
dataSet = []


class PEMachineLearning(QMainWindow):
    def __init__(self):
        super(PEMachineLearning,self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.show()
        
        self.figure = Figure()
        self.canvas = FigureCanvas(self.figure)

        self.elbow_figure = Figure()
        self.elbow_canvas = FigureCanvas(self.elbow_figure)
        
        self.ui.cluster_spin_box.setMinimum(2)
        self.ui.directory_browse_button.clicked.connect(self.setBinaryPath)
        self.ui.refresh_cluster.clicked.connect(self.clusterPlot)
        self.ui.refresh_silhouette.clicked.connect(self.populateTable)
        self.ui.refresh_elbow.clicked.connect(self.elbow)
        layout = QtWidgets.QVBoxLayout(self.ui.clustering_frame)
        layout.addWidget(self.canvas)
        layout = QtWidgets.QVBoxLayout(self.ui.elbow_frame)
        layout.addWidget(self.elbow_canvas)
        self.ui.silhouette_table.horizontalHeader().show()



    def insertTableItem(self,item1,item2,item3,item4,item5):
        row_number = self.ui.silhouette_table.rowCount()
        self.ui.silhouette_table.insertRow(row_number)
        
        self.ui.silhouette_table.setItem(row_number, 0, QTableWidgetItem(str(item1)))
        self.ui.silhouette_table.setItem(row_number, 1, QTableWidgetItem(str(item2)))
        self.ui.silhouette_table.setItem(row_number, 2, QTableWidgetItem(str(item3)))
        self.ui.silhouette_table.setItem(row_number, 3, QTableWidgetItem(str(item4)))
        self.ui.silhouette_table.setItem(row_number, 4, QTableWidgetItem(str(item5)))
        
        QtCore.QCoreApplication.processEvents()
        
    def getFileNames(self):
        with open('files.csv', 'r') as files_csv:
          reader = csv.reader(files_csv)
          return list(reader)[0]
        
    def populateTable(self):
        bestScore = -1
        bestDecomp =''
        bestCluster = -1
        files = self.getFileNames()
        self.ui.silhouette_table.setRowCount(0)
        
        data = self.readCSVToNumpyArray()
        min_ = self.ui.min_cluster_spin_box.value()
        max_ = self.ui.max_cluster_spin_box.value()

        dataSet = self.doPca(data)
        while(min_ <= max_):
            alg = KMeans(n_clusters=min_)
            alg.fit(dataSet)
            cluster_labels = alg.fit_predict(dataSet)
            score= self.getSilhouetteScore(cluster_labels, dataSet)
            if(bestScore < score):
                bestScore = score
                bestCluster = min_
                bestDecomp ="PCA"
            accuracy = self.calculateAccuracy(cluster_labels,files)
            self.insertTableItem(min_,"PCA","KMeans",score,accuracy)
            min_ +=1
        
        bandwidth = estimate_bandwidth(dataSet, quantile=0.2)
        alg = MeanShift(bandwidth=bandwidth)
        alg.fit(dataSet)
        cluster_labels = alg.fit_predict(dataSet)
        number_clusters = len(np.unique(cluster_labels))
        score= self.getSilhouetteScore(cluster_labels, dataSet)
        accuracy = self.calculateAccuracy(cluster_labels,files)
        self.insertTableItem(number_clusters,"PCA","MeanShift",score,accuracy)
        
        min_ = self.ui.min_cluster_spin_box.value()
        max_ = self.ui.max_cluster_spin_box.value()
        dataSet = self.doNmf(data)
        while(min_ <= max_):
            alg = KMeans(n_clusters=min_)
            alg.fit(dataSet)
            cluster_labels = alg.fit_predict(dataSet)
            score = self.getSilhouetteScore(cluster_labels, dataSet)
            if(bestScore < score):
                bestScore = score
                bestCluster = min_
                bestDecomp = "NMF"
            accuracy = self.calculateAccuracy(cluster_labels,files)
            self.insertTableItem(min_,"NMF","KMeans",score,accuracy)
            min_ +=1
        
        bandwidth = estimate_bandwidth(dataSet, quantile=0.2)
        alg = MeanShift(bandwidth=bandwidth)
        alg.fit(dataSet)
        cluster_labels = alg.fit_predict(dataSet)
        number_clusters = len(np.unique(cluster_labels))
        score= self.getSilhouetteScore(cluster_labels, dataSet)
        accuracy = self.calculateAccuracy(cluster_labels,files)
        self.insertTableItem(number_clusters,"NMF","MeanShift",score,accuracy)
        self.ui.optimum_clusters.setText(str(bestCluster) + " Clusters with " + bestDecomp)
        QtCore.QCoreApplication.processEvents()
    
    def setBinaryPath(self):
        dialog = QFileDialog()
        directory = str(dialog.getExistingDirectory(dialog,"Select Directory"))
        filelist = self.extractFeaturesToCsv(directory)
        self.clusterPlot()
        return filelist

    def clusterPlot(self):
        number_clusters = self.ui.cluster_spin_box.value()
        decomposition = str(self.ui.decomp_combo.currentText())
        alg_name = str(self.ui.cluster_combo.currentText())
        show_centroids = False
        if(self.ui.extra_plot_check_box.isChecked()):
            show_centroids =True
        
        self.figure.clf()
        dataSet = self.readCSVToNumpyArray()
        
        if(decomposition == "PCA"):
            dataSet = self.doPcaAndPlot(dataSet)
        elif(decomposition == "NMF"):
            dataSet = self.doNmfAndPlot(dataSet)
            
        if(alg_name == "KMeans"):
            alg = KMeans(n_clusters=number_clusters)
            alg.fit(dataSet)
            cluster_labels = alg.fit_predict(dataSet)
            self.simpleClusterPlot(alg,alg_name,cluster_labels,number_clusters, show_centroids,dataSet)
        else:
            bandwidth = estimate_bandwidth(dataSet, quantile=0.2)
            alg = MeanShift(bandwidth=bandwidth)
            alg.fit(dataSet)
            cluster_labels = alg.fit_predict(dataSet)
            number_clusters = len(np.unique(cluster_labels))
            self.simpleClusterPlot(alg,alg_name,cluster_labels,number_clusters,show_centroids,dataSet)
            
        self.colorMapPlot(alg,number_clusters,show_centroids,dataSet)
        self.silhouettePlot(alg,cluster_labels, number_clusters, dataSet)
        self.canvas.draw()

    def HexToDec(self,hexString):
        return int(hexString, base=16)
    
    def readCSVToNumpyArray(self):
        data = genfromtxt('features.csv', delimiter=',')
        return data
        
    def doPcaAndPlot(self, data):
        pca = PCA(n_components=2)
        pca.fit(data[1:])
        dataSet = pca.transform(data[1:])
        ax = self.figure.add_subplot(221)
        ax.scatter(dataSet[:, 0], dataSet[:, 1])
        return dataSet
        
    def doPca(self, data):
        pca = PCA(n_components=2)
        pca.fit(data[1:])
        dataSet = pca.transform(data[1:])
        return dataSet
        
    def doNmfAndPlot(self, data):
        nmf = NMF(n_components=2)
        nmf.fit(data[1:])
        dataSet = nmf.transform(data[1:])
        ax = self.figure.add_subplot(221)
        ax.scatter(dataSet[:, 0], dataSet[:, 1])
        return dataSet
    
    def doNmf(self, data):
        nmf = NMF(n_components=2)
        nmf.fit(data[1:])
        dataSet = nmf.transform(data[1:])
        return dataSet
    
    def silhouettePlot(self,cluster_alg, cluster_labels, no_clusters, dataSet):
        ax1 = self.figure.add_subplot(224)
        ax1.set_xlim([-1, 1])
        ax1.set_ylim([0, len(dataSet) + (no_clusters + 1) * 5])
    
        score = silhouette_score(dataSet, cluster_labels)
        # Compute the silhouette scores for each sample
        sample_silhouette_values = silhouette_samples(dataSet, cluster_labels)
    
        y_lower = 5
        for i in range(no_clusters):
            # Aggregate the silhouette scores for samples belonging to
            # cluster i, and sort them
            silhouette_values = \
                sample_silhouette_values[cluster_labels == i]
    
            silhouette_values.sort()
    
            size_cluster_i = silhouette_values.shape[0]
            y_upper = y_lower + size_cluster_i
    
            color = cm.spectral(float(i) / no_clusters)
            ax1.fill_betweenx(np.arange(y_lower, y_upper),
                              0, silhouette_values,
                              facecolor=color, edgecolor=color, alpha=0.7)
    
            # Label the silhouette plots with their cluster numbers at the middle
            ax1.text(-0.07, y_lower + 0.5 * size_cluster_i, str(i))
            
            y_lower = y_upper + 5 
    
        ax1.set_title("Silhouette Plot for "+ str(no_clusters)+ " Clusters")
        ax1.set_xlabel("Silhouette Coeeficient")
        ax1.set_ylabel("Cluster Number")
    
        # Display a dotted line at the average score
        ax1.axvline(x=score, color="red", linestyle="--")
    
        ax1.set_yticks(())
        ax1.set_xticks([-1.0,-0.8,-0.6,-0.4,-0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
        self.ui.silhouette_score_label.setText("Silhouette score: "+ str(score) )

        QtCore.QCoreApplication.processEvents()
        
    def getSilhouetteScore(self,cluster_labels,dataSet):
        return silhouette_score(dataSet, cluster_labels)

    def simpleClusterPlot(self, alg, alg_name,labels, no_clusters, includeCentroids, dataSet):
        ax2 = self.figure.add_subplot(222)
        x_min = dataSet[:,0].min() - 1
        x_max = dataSet[:,0].max() + 1
        y_min= dataSet[:,1].min() - 1 
        y_max = dataSet[:,1].max() + 1
        colors = cm.spectral(labels.astype(float) / no_clusters)
        
        ax2.scatter(dataSet[:, 0], dataSet[:, 1], c=colors, lw=0, alpha=0.6)
        cluster_centers = alg.cluster_centers_
        if(includeCentroids):
            ax2.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                    marker='o', c="white", alpha=1, s=200)
    
            for i, c in enumerate(cluster_centers):
                ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)

        if(alg_name == "KMeans"):
            ax2.set_title("Simple KMeans Plot for "+ str(no_clusters)+ " Clusters")
        elif(alg_name == "MeanShift"):
            ax2.set_title("Simple MeanShift Plot. Estimated Clusters : "+str(no_clusters))
        ax2.set_xlim(x_min, x_max)
        ax2.set_ylim(y_min, y_max)
        
        
    def calculateAccuracy(self,labels,files):
        
        malLabel = 0
        benLabel = 0
        correct = 0
        
        if(str(files[0])[:3] == "MAL"):
            malLabel = labels[0]
            benLabel = abs(malLabel - 1) 
        elif(str(files[0])[:3]=="BEN"):
            benLabel = labels[0]
            malLabel = abs(benLabel - 1) 
    
        for i in range(len(files)):
            if(str(files[i])[:3] == "MAL" and labels[i] == malLabel):
                correct += 1
    
            elif(str(files[i])[:3] == "BEN" and labels[i] == benLabel):
                correct += 1
        
        return correct/len(files)*100
    
    def extractFeaturesToCsv(self,directory):
        files =[]
        with open('features.csv', 'w') as csvfile:
            with open('files.csv', 'w') as filenames_csv:
                writer = csv.writer(csvfile, quoting=csv.QUOTE_NONE)
                file_writer = csv.writer(filenames_csv, quoting=csv.QUOTE_NONE)
                fieldnames = [ 'Section1Entropy','Section2Entropy','Section3Entropy','Section4Entropy','FileEntropy','CodeDataRatio','MajorImageVersion', 'NumberOfSections']
                writer.writerow(fieldnames)
                numberFiles=0
                self.ui.ExtractionProgress.setValue(0)
                QtCore.QCoreApplication.processEvents()
                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        numberFiles +=1
                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        files.append(filename)
                        self.ui.FileExtractionLabel.setText("Extracting features from: "+ filename )
    
                        QtCore.QCoreApplication.processEvents()
                        with open(directory+'/'+filename,"rb") as bufferedReader:
    
                            peFile= PE32()
                            peFile.File(bufferedReader, directory+'/'+filename)
        
                            sectionEntropy = [0] * peFile.GetNumberOfSections()
                     
                            for index in range(peFile.GetNumberOfSections()):
                                Offset = peFile.GetSectionPointerToRawData(index)
                                Length = peFile.GetSectionSizeOfRawData(index)
                                Entropy = peFile.CalculateEntropy(self.HexToDec(Offset),self.HexToDec(Length))
                                sectionEntropy[index] = Entropy
    
                            FileEntropy = peFile.GetFileEntropy()
                            CodeDataRatio = peFile.GetCodeDataRatio()
                            
                            row = [0] * 8
                            
                            for i in range(4):
                                if i >= peFile.GetNumberOfSections():
                                    row[i] = 0
                                else:
                                    row[i] = sectionEntropy[i]
        
                            row[4] = FileEntropy
                            row[5] = CodeDataRatio
                            row[6] = self.HexToDec(peFile.GetMajorImageVersion())
                            row[7] = peFile.GetNumberOfSections()
    
                            writer.writerow(row)
                            value = self.ui.ExtractionProgress.value() + round(100/numberFiles) 
                            if(value>100):
                                self.ui.ExtractionProgress.setValue(100)
                            else:
                                self.ui.ExtractionProgress.setValue(value)
                file_writer.writerow(files)
            self.ui.ExtractionProgress.setValue(100)
            self.ui.FileExtractionLabel.setText("Feature Extraction Complete")
            QtCore.QCoreApplication.processEvents()


            
    def colorMapPlot(self, cluster_alg, no_clusters,includeCentroids, dataSet):
        stepSize = .01
        ax = self.figure.add_subplot(223)
    
        # Find x and y minimum and maximum values. This is used in the generation of step values for the grid
        x_min = dataSet[:,0].min() - 1
        x_max = dataSet[:,0].max() + 1
        y_min= dataSet[:,1].min() - 1 
        y_max = dataSet[:,1].max() + 1
        
        # Generate step values
        x_step_values = np.arange(x_min, x_max, stepSize)
        y_step_values = np.arange(y_min, y_max, stepSize)
        
        # Create grid from step values
        x_grid_values, y_grid_values = np.meshgrid(x_step_values, y_step_values)
        
        # Label each point on the grid
        labels = cluster_alg.predict(np.c_[x_grid_values.ravel(), y_grid_values.ravel()])
        
        # Plot each point of the grid, assigning a color based on where it is is in relation to discriminant lines
        labels = labels.reshape(x_grid_values.shape)
        ax.imshow(labels, interpolation='nearest',
                   extent=(x_grid_values.min(), x_grid_values.max(), y_grid_values.min(), y_grid_values.max()),
                   cmap= 'RdYlGn',
                   aspect='auto', origin='lower')
        
        ax.plot(dataSet[:, 0], dataSet[:, 1], 'k.', markersize= 8)
        
        cluster_centers = cluster_alg.cluster_centers_
        if(includeCentroids):
            ax.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                    marker='o', c="white", alpha=1, s=200, zorder=19)
    
            for i, c in enumerate(cluster_centers):
                ax.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50, zorder=20)
        
        ax.set_title("Color Map Plot for "+ str(no_clusters)+ " Clusters")
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        ax.set_xticks(())
        ax.set_yticks(())
        

    def elbow(self):
        self.elbow_figure.clf()
        elbow_scores = []
        min_ = self.ui.min_cluster_spin_box_elbow.value()
        max_ = self.ui.max_cluster_spin_box_elbow.value()

        number_clusters = range(min_,max_+1, 1)
        
        data = self.readCSVToNumpyArray()

        dataSet = self.doPca(data)
        while min_ <= max_: 
            km = KMeans(n_clusters=min_)
            elbow_scores.append(abs(km.fit(dataSet).score(dataSet)))
            min_ +=1
            
        ax=self.elbow_figure.add_subplot(121)
        ax.plot(number_clusters, elbow_scores)
        ax.set_title("KMeans Elbow Plot for PCA Decomposition")
        ax.set_ylabel("Cost Funtion of K")
        ax.set_xlabel("Number of Clusters")
        
        min_ = self.ui.min_cluster_spin_box_elbow.value()
        max_ = self.ui.max_cluster_spin_box_elbow.value()
        dataSet = self.doNmf(data)
        elbow_scores = []
        while min_ <= max_: 
            km = KMeans(n_clusters=min_)
            elbow_scores.append(abs(km.fit(dataSet).score(dataSet)))
            min_ +=1
        
        ax =self.elbow_figure.add_subplot(122)
        ax.plot(number_clusters, elbow_scores)
        ax.set_title("KMeans Elbow Plot for NMF Decomposition")
        ax.set_ylabel("Cost Funtion of K")
        ax.set_xlabel("Number of Clusters")
        self.elbow_canvas.draw()
        
app = QApplication(sys.argv)
ex = PEMachineLearning()
sys.exit(app.exec_())
    
