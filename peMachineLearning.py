import sys
import os
import numpy as np
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.cm as cm
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QTableWidgetItem
from PyQt5 import QtCore, QtWidgets
from sklearn.decomposition import PCA, NMF
from sklearn.cluster import KMeans
from sklearn.cluster import MeanShift, estimate_bandwidth
from sklearn.metrics import silhouette_samples, silhouette_score
from mainwindow import Ui_MainWindow
from PEFile import PE32
from PeUtil import *


class PEMachineLearning(QMainWindow):
    def __init__(self):
        super(PEMachineLearning, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.show()
        self.figure = Figure()
        self.canvas = FigureCanvas(self.figure)
        self.elbow_figure = Figure()
        self.elbow_canvas = FigureCanvas(self.elbow_figure)
        self.ui.cluster_spin_box.setMinimum(2)
        self.ui.directory_browse_button.clicked.connect(self.set_binary_path)
        self.ui.refresh_cluster.clicked.connect(self.cluster_plot)
        self.ui.refresh_silhouette.clicked.connect(self.populate_table)
        self.ui.refresh_elbow.clicked.connect(self.elbow)
        layout = QtWidgets.QVBoxLayout(self.ui.clustering_frame)
        layout.addWidget(self.canvas)
        layout = QtWidgets.QVBoxLayout(self.ui.elbow_frame)
        layout.addWidget(self.elbow_canvas)
        self.ui.silhouette_table.horizontalHeader().show()

    def insert_table_item(self, item1, item2, item3, item4, item5, item6, item7):
        row_number = self.ui.silhouette_table.rowCount()
        self.ui.silhouette_table.insertRow(row_number)
        self.ui.silhouette_table.setItem(row_number, 0, QTableWidgetItem(str(item1)))
        self.ui.silhouette_table.setItem(row_number, 1, QTableWidgetItem(str(item2)))
        self.ui.silhouette_table.setItem(row_number, 2, QTableWidgetItem(str(item3)))
        self.ui.silhouette_table.setItem(row_number, 3, QTableWidgetItem(str(item4)))
        self.ui.silhouette_table.setItem(row_number, 4, QTableWidgetItem(str(item5)))
        self.ui.silhouette_table.setItem(row_number, 5, QTableWidgetItem(str(item6)))
        self.ui.silhouette_table.setItem(row_number, 6, QTableWidgetItem(str(item7)))
        QtCore.QCoreApplication.processEvents()

    def populate_table(self):
        best_score = -1
        best_decomp = ''
        best_cluster = -1
        files = get_file_names()
        self.ui.silhouette_table.setRowCount(0)
        data = read_csv_to_numpy_array()
        
        results = []
        with open('results.csv', 'w') as results_csv:
            writer = csv.writer(results_csv, quoting=csv.QUOTE_NONE)
           
            max_components = self.ui.component_spinner.value()
            for components in range(1, max_components+1): 
                min_ = self.ui.min_cluster_spin_box.value()
                max_ = self.ui.max_cluster_spin_box.value()
                
                data_set = do_pca(data, components)
                while min_ <= max_:
                    alg = KMeans(n_clusters=min_)
                    alg.fit(data_set)
                    cluster_labels = alg.fit_predict(data_set)
                    score = get_silhouette_score(cluster_labels, data_set)
                    if best_score < score:
                        best_score = score
                        best_cluster = min_
                        best_decomp = "PCA"
    
                    det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                    clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                    results.append("PCA")
                    results.append(components)
                    results.append("KMEANS")
                    results.append(min_)
                    results.append(score)
                    results.append(det_accuracy)
                    results.append(clu_accuracy)
                    writer.writerow(results)
                    results =[]
                    self.insert_table_item("PCA",components, "KMeans", min_, score, det_accuracy, clu_accuracy)
                    min_ += 1
        
                bandwidth = estimate_bandwidth(data_set, quantile=0.2)
                alg = MeanShift(bandwidth=bandwidth)
                alg.fit(data_set)
                cluster_labels = alg.fit_predict(data_set)
                number_clusters = len(np.unique(cluster_labels))
                score = get_silhouette_score(cluster_labels, data_set)
                det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                results.append("PCA")
                results.append(components)
                results.append("MEANSHIFT")
                results.append(number_clusters)
                results.append(score)
                results.append(det_accuracy)
                results.append(clu_accuracy)
                writer.writerow(results)
                results =[]
                self.insert_table_item("PCA",components, "MeanShift", number_clusters, score, det_accuracy, clu_accuracy)
        
                min_ = self.ui.min_cluster_spin_box.value()
                max_ = self.ui.max_cluster_spin_box.value()
                data_set = do_nmf(data, components)
                while min_ <= max_:
                    alg = KMeans(n_clusters=min_)
                    alg.fit(data_set)
                    cluster_labels = alg.fit_predict(data_set)
                    score = get_silhouette_score(cluster_labels, data_set)
                    if best_score < score:
                        best_score = score
                        best_cluster = min_
                        best_decomp = "NMF"
                    det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                    clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                    results.append("NMF")
                    results.append(components)
                    results.append("KMEANS")
                    results.append(min_)
                    results.append(score)
                    results.append(det_accuracy)
                    results.append(clu_accuracy)
                    writer.writerow(results)
                    results=[]
                    self.insert_table_item("NMF",components, "KMeans", min_, score, det_accuracy, clu_accuracy)
                    min_ += 1
        
                bandwidth = estimate_bandwidth(data_set, quantile=0.2)
                alg = MeanShift(bandwidth=bandwidth)
                alg.fit(data_set)
                cluster_labels = alg.fit_predict(data_set)
                number_clusters = len(np.unique(cluster_labels))
                score = get_silhouette_score(cluster_labels, data_set)
                det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                results.append("NMF")
                results.append(components)
                results.append("MEANSHIFT")
                results.append(number_clusters)
                results.append(score)
                results.append(det_accuracy)
                results.append(clu_accuracy)
                writer.writerow(results)
                results =[]
                self.insert_table_item("NMF",components, "MeanShift", number_clusters, score, det_accuracy, clu_accuracy)
                self.ui.optimum_clusters.setText(str(best_cluster) + " Clusters with " + best_decomp)
                QtCore.QCoreApplication.processEvents()

    def set_binary_path(self):
        dialog = QFileDialog()
        directory = str(dialog.getExistingDirectory(dialog, "Select Directory"))
        self.extract_features_to_csv(directory)
        self.cluster_plot()

    def cluster_plot(self):
        number_clusters = self.ui.cluster_spin_box.value()

        decomposition = str(self.ui.decomp_combo.currentText())

        alg_name = str(self.ui.cluster_combo.currentText())

        show_centroids = False
        if self.ui.extra_plot_check_box.isChecked():
            show_centroids = True

        self.figure.clf()

        data_set = read_csv_to_numpy_array()

        if decomposition == "PCA":
            data_set = self.do_pca_and_plot(data_set)

        elif decomposition == "NMF":
            data_set = self.do_nmf_and_plot(data_set)

        if alg_name == "KMeans":
            alg = KMeans(n_clusters=number_clusters)
            alg.fit(data_set)
            cluster_labels = alg.fit_predict(data_set)

            self.simple_cluster_plot(alg, alg_name, cluster_labels, number_clusters, show_centroids, data_set)
        else:
            bandwidth = estimate_bandwidth(data_set, quantile=0.2)
            alg = MeanShift(bandwidth=bandwidth)
            alg.fit(data_set)
            cluster_labels = alg.fit_predict(data_set)
            number_clusters = len(np.unique(cluster_labels))
            self.simple_cluster_plot(alg, alg_name, cluster_labels, number_clusters, show_centroids, data_set)

        self.color_map_plot(alg, number_clusters, show_centroids, data_set)

        self.silhouette_plot(cluster_labels, number_clusters, data_set)

        self.canvas.draw()

    def do_pca_and_plot(self, data):
        pca = PCA(n_components=2)
        pca.fit(data[1:])
        data_set = pca.transform(data[1:])
        ax = self.figure.add_subplot(221)
        ax.scatter(data_set[:, 0], data_set[:, 1])
        return data_set

    def do_nmf_and_plot(self, data):
        nmf = NMF(n_components=2)
        nmf.fit(data[1:])
        data_set = nmf.transform(data[1:])
        ax = self.figure.add_subplot(221)
        ax.scatter(data_set[:, 0], data_set[:, 1])
        return data_set

    def silhouette_plot(self, cluster_labels, no_clusters, data_set):
        ax1 = self.figure.add_subplot(224)
        ax1.set_xlim([-1, 1])
        ax1.set_ylim([0, len(data_set) + (no_clusters + 1) * 5])

        score = silhouette_score(data_set, cluster_labels)
        sample_silhouette_values = silhouette_samples(data_set, cluster_labels)

        y_lower = 5
        for i in range(no_clusters):
            silhouette_values = sample_silhouette_values[cluster_labels == i]

            silhouette_values.sort()

            size_cluster_i = silhouette_values.shape[0]
            y_upper = y_lower + size_cluster_i

            color = cm.spectral(float(i) / no_clusters)
            ax1.fill_betweenx(np.arange(y_lower, y_upper),
                              0, silhouette_values,
                              facecolor=color, edgecolor=color, alpha=0.7)

            ax1.text(-0.07, y_lower + 0.5 * size_cluster_i, str(i))

            y_lower = y_upper + 5

        ax1.set_title("Silhouette Plot for " + str(no_clusters) + " Clusters")
        ax1.set_xlabel("Silhouette Coeeficient")
        ax1.set_ylabel("Cluster Number")

        # Display a dotted line at the average score
        ax1.axvline(x=score, color="red", linestyle="--")

        ax1.set_yticks(())
        ax1.set_xticks([-1.0, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
        self.ui.silhouette_score_label.setText("Silhouette score: " + str(score))

        QtCore.QCoreApplication.processEvents()

    def simple_cluster_plot(self, alg, alg_name, labels, no_clusters, include_centroids, data_set):
        x_min = data_set[:, 0].min() - 5
        x_max = data_set[:, 0].max() + 5
        y_min = data_set[:, 1].min() - 1
        y_max = data_set[:, 1].max() + 1
        
        ax2 = self.figure.add_subplot(222)
        colors = cm.spectral(labels.astype(float) / no_clusters)

        ax2.scatter(data_set[:, 0], data_set[:, 1], c=colors, lw=0, alpha=0.6)
        cluster_centers = alg.cluster_centers_
        if include_centroids:
            ax2.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                        marker='o', c="white", alpha=1, s=200)

            for i, c in enumerate(cluster_centers):
                ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)

        if alg_name == "KMeans":
            ax2.set_title("Simple KMeans Plot for " + str(no_clusters) + " Clusters")
        elif alg_name == "MeanShift":
            ax2.set_title("Simple MeanShift Plot. Estimated Clusters : " + str(no_clusters))
        ax2.set_xlim(x_min, x_max)
        ax2.set_ylim(y_min, y_max)

    def extract_features_to_csv(self, directory):
        self.ui.ExtractionProgress.setValue(0)
        QtCore.QCoreApplication.processEvents()

        files = []
        with open('features.csv', 'w') as csvfile:
            with open('files.csv', 'w') as filenames_csv:
                writer = csv.writer(csvfile, quoting=csv.QUOTE_NONE)
                file_writer = csv.writer(filenames_csv, quoting=csv.QUOTE_NONE)
                field_names = ['Section1Entropy', 'Section2Entropy', 'Section3Entropy', 'Section4Entropy',
                               'FileEntropy', 'CodeDataRatio', 'MajorImageVersion', 'NumberOfSections', 'KERNEL32.DLL',
                               'USER32.DLL', 'ADVAPI32.dll', 'msvcrt.dll', 'GDI32.dll', 'SHELL32.dll', 'ole32.dll',
                               'WS2_32.dll', 'SHLWAPI.dll', 'COMCTL32.dll']
                writer.writerow(field_names)
                number_files = 0

                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        number_files += 1
                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        files.append(filename)
                        self.ui.FileExtractionLabel.setText("Extracting features from: " + filename)
                        QtCore.QCoreApplication.processEvents()
                        with open(directory + '/' + filename, "rb") as bufferedReader:
                            pe_file = PE32()
                            pe_file.File(bufferedReader, filename, directory)
                            row = perform_feature_extraction(pe_file)
                            writer.writerow(row)
                            value = self.ui.ExtractionProgress.value() + round(1000 / float(number_files))
                            print(value)
                            if value > 1000:
                                self.ui.ExtractionProgress.setValue(1000)
                            else:
                                self.ui.ExtractionProgress.setValue(value)
                            

                file_writer.writerow(files)
            self.ui.ExtractionProgress.setValue(1000)
            self.ui.FileExtractionLabel.setText("Feature Extraction Complete")
            QtCore.QCoreApplication.processEvents()

    def color_map_plot(self, cluster_alg, no_clusters, include_centroids, data_set):

        ax = self.figure.add_subplot(223)

        # Find x and y minimum and maximum values. This is used in the generation of step values for the grid
        x_min = data_set[:, 0].min() - 5
        x_max = data_set[:, 0].max() + 5
        y_min = data_set[:, 1].min() - 1
        y_max = data_set[:, 1].max() + 1

        step_size = .01

        # Generate step values
        x_step_values = np.arange(x_min, x_max, step_size)
        y_step_values = np.arange(y_min, y_max, step_size)

        # Create grid from step values
        x_grid_values, y_grid_values = np.meshgrid(x_step_values, y_step_values)

        # Label each point on the grid
        labels = cluster_alg.predict(np.c_[x_grid_values.ravel(), y_grid_values.ravel()])

        # Plot each point of the grid, assigning a color based on where it is is in relation to discriminant lines
        labels = labels.reshape(x_grid_values.shape)
        ax.imshow(labels, interpolation='nearest',
                  extent=(x_grid_values.min(), x_grid_values.max(), y_grid_values.min(), y_grid_values.max()),
                  cmap='RdYlGn',
                  aspect='auto', origin='lower')

        ax.plot(data_set[:, 0], data_set[:, 1], 'k.', markersize=8)

        cluster_centers = cluster_alg.cluster_centers_
        if include_centroids:
            ax.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                       marker='o', c="white", alpha=1, s=200, zorder=19)

            for i, c in enumerate(cluster_centers):
                ax.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50, zorder=20)

        ax.set_title("Color Map Plot for " + str(no_clusters) + " Clusters")
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        ax.set_xticks(())
        ax.set_yticks(())

    def elbow(self):
        self.elbow_figure.clf()
        elbow_scores = []
        min_ = self.ui.min_cluster_spin_box_elbow.value()
        max_ = self.ui.max_cluster_spin_box_elbow.value()
        components = self.ui.components_spinner_elbow.value()
        number_clusters = range(min_, max_ + 1, 1)

        data = read_csv_to_numpy_array()

        data_set = do_pca(data, components)
        while min_ <= max_:
            km = KMeans(n_clusters=min_)
            elbow_scores.append(abs(km.fit(data_set).score(data_set)))
            min_ += 1

        ax = self.elbow_figure.add_subplot(121)
        ax.plot(number_clusters, elbow_scores)
        ax.set_title("KMeans Elbow Plot for PCA Decomposition")
        ax.set_ylabel("Cost Funtion of K")
        ax.set_xlabel("Number of Clusters")

        min_ = self.ui.min_cluster_spin_box_elbow.value()
        max_ = self.ui.max_cluster_spin_box_elbow.value()
        data_set = do_nmf(data, components)
        elbow_scores = []
        while min_ <= max_:
            km = KMeans(n_clusters=min_)
            elbow_scores.append(abs(km.fit(data_set).score(data_set)))
            min_ += 1

        ax = self.elbow_figure.add_subplot(122)
        ax.plot(number_clusters, elbow_scores)
        ax.set_title("KMeans Elbow Plot for NMF Decomposition")
        ax.set_ylabel("Cost Funtion of K")
        ax.set_xlabel("Number of Clusters")
        self.elbow_canvas.draw()


app = QApplication(sys.argv)
ex = PEMachineLearning()
sys.exit(app.exec_())
