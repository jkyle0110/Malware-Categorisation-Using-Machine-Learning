import os
import sys

import matplotlib.cm as cm
import numpy as np
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QTableWidgetItem
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from sklearn.cluster import KMeans
from sklearn.cluster import MeanShift, estimate_bandwidth
from sklearn.decomposition import PCA, NMF
from sklearn.metrics import silhouette_samples, silhouette_score

from pe_file import PE32
from pe_util import *
from mainwindow import Ui_MainWindow


class PEMachineLearning(QMainWindow):
    # Constructor
    def __init__(self):
        # Initialise super class which contains the UI components
        super(PEMachineLearning, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.show()
        # Create a figure on which we can plot grpahs
        self.figure = Figure()
        self.elbow_figure = Figure()
        # Create a canvas on the figure
        self.canvas = FigureCanvas(self.figure)
        self.elbow_canvas = FigureCanvas(self.elbow_figure)
        
        self.ui.cluster_spin_box.setMinimum(2)
        # Assign events to button clicks
        self.ui.directory_browse_button.clicked.connect(self.set_binary_path)
        self.ui.refresh_cluster.clicked.connect(self.cluster_plot)
        self.ui.refresh_silhouette.clicked.connect(self.populate_table)
        self.ui.refresh_elbow.clicked.connect(self.elbow)
        
        # Assign box layouts to frames which will hold the canvas and figure components
        layout = QtWidgets.QVBoxLayout(self.ui.clustering_frame)
        layout.addWidget(self.canvas)
        layout = QtWidgets.QVBoxLayout(self.ui.elbow_frame)
        layout.addWidget(self.elbow_canvas)
        
        # Show headers 
        self.ui.silhouette_table.horizontalHeader().show()
    
    # Insert row into table with 7 items corresponding to the 7 columns
    def insert_table_item(self, item1, item2, item3, item4, item5, item6, item7):
        # Always insert at the next available row
        row_number = self.ui.silhouette_table.rowCount()
        self.ui.silhouette_table.insertRow(row_number)
        
        self.ui.silhouette_table.setItem(row_number, 0, QTableWidgetItem(str(item1)))
        self.ui.silhouette_table.setItem(row_number, 1, QTableWidgetItem(str(item2)))
        self.ui.silhouette_table.setItem(row_number, 2, QTableWidgetItem(str(item3)))
        self.ui.silhouette_table.setItem(row_number, 3, QTableWidgetItem(str(item4)))
        self.ui.silhouette_table.setItem(row_number, 4, QTableWidgetItem(str(round(item5,3))))
        self.ui.silhouette_table.setItem(row_number, 5, QTableWidgetItem(str(round(item6,3))))
        self.ui.silhouette_table.setItem(row_number, 6, QTableWidgetItem(str(round(item7,3))))
        
        # Update UI Thread
        QtCore.QCoreApplication.processEvents()

    
    def populate_table(self):
        # Inialise varables for storing recommendations
        best_score = -1
        best_decomp = ''
        best_cluster = -1
        
        # Read filenames in sequence
        files = get_file_names()
        
        # Empty Table
        self.ui.silhouette_table.setRowCount(0)
        
        # Read  featuredata from csv
        data = read_csv_to_numpy_array()
        
        results = []
        
        # Open results csv
        with open('results.csv', 'w') as results_csv:
            writer = csv.writer(results_csv, quoting=csv.QUOTE_NONE)
           
            max_components = self.ui.components_spinner.value()
            # Repeat from 1 to max compoennts
            for components in range(1, max_components+1): 
                # Repeat for both PCA and NMF
                for decomposition_algorithm in ["PCA", "NMF"]:
                    # Set values to loop between from UI spinners
                    min_ = self.ui.min_cluster_spin_box.value()
                    max_ = self.ui.max_cluster_spin_box.value()
                    
                    # Perform chosen decomposition
                    if decomposition_algorithm == "PCA":
                        data_set = do_pca(data, components)
                    elif decomposition_algorithm == "NMF":
                        data_set = do_nmf(data, components)
                    
                    # Repeat until max clusters is reached
                    while min_ <= max_:
                        # Perform KMeans Clustering with specified number of clusters - stored in min_
                        alg = KMeans(n_clusters=min_)
                        alg.fit(data_set)
                        
                        # Calculate data for results
                        cluster_labels = alg.fit_predict(data_set)
                        score = get_silhouette_score(cluster_labels, data_set)
                        det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                        clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                        
                        if best_score < score:
                            best_score = score
                            best_cluster = min_
                            best_decomp = decomposition_algorithm
                            
                        # Append results to csv for easy parsing
                        results.append(decomposition_algorithm)
                        results.append(components)
                        results.append("KMEANS")
                        results.append(min_)
                        results.append(score)
                        results.append(det_accuracy)
                        results.append(clu_accuracy)
                        writer.writerow(results)
                        results =[]
                        
                        # Display results in UI
                        self.insert_table_item(decomposition_algorithm, components, "KMeans", min_, score, det_accuracy, clu_accuracy)
                        # Increment min_ up until it is greater than max_
                        min_ += 1
                    
                    # Perform MeanShift Clustering
                    bandwidth = estimate_bandwidth(data_set, quantile=0.2)
                    alg = MeanShift(bandwidth=bandwidth)
                    alg.fit(data_set)
                    
                    # Calculate data for results
                    cluster_labels = alg.fit_predict(data_set)
                    number_clusters = len(np.unique(cluster_labels))
                    score = get_silhouette_score(cluster_labels, data_set)
                    det_accuracy = calculate_detection_accuracy(cluster_labels, files)
                    clu_accuracy = calculate_cluster_accuracy(cluster_labels, files)
                    
                    # Append results to csv for easy parsing
                    results.append(decomposition_algorithm)
                    results.append(components)
                    results.append("MEANSHIFT")
                    results.append(number_clusters)
                    results.append(score)
                    results.append(det_accuracy)
                    results.append(clu_accuracy)
                    writer.writerow(results)
                    results =[]
                    
                    # Display results in UI
                    self.insert_table_item(decomposition_algorithm, components, "MeanShift", number_clusters, score, det_accuracy, clu_accuracy)
                    
                    # Update UI thread
                    self.ui.optimum_clusters.setText(str(best_cluster) + " Clusters with " + best_decomp)
                    QtCore.QCoreApplication.processEvents()
    
    # Create a file dialog and begin feature extraction, plot graph when feature extraction is complete
    def set_binary_path(self):
        dialog = QFileDialog()
        directory = str(dialog.getExistingDirectory(dialog, "Select Directory"))
        self.extract_features_to_csv(directory)
        self.cluster_plot()

    #
    def cluster_plot(self):
        # Get user choices from UI dropdowns and spinners
        number_clusters = self.ui.cluster_spin_box.value()
        decomposition = str(self.ui.decomp_combo.currentText())
        alg_name = str(self.ui.cluster_combo.currentText())

        show_centroids = False
        if self.ui.extra_plot_check_box.isChecked():
            show_centroids = True

        # Clear existing figure
        self.figure.clf()

        # read extracted features from csv
        data_set = read_csv_to_numpy_array()

        # Perform chosen decomposition
        if decomposition == "PCA":
            data_set = self.do_pca_and_plot(data_set)
        elif decomposition == "NMF":
            data_set = self.do_nmf_and_plot(data_set)

        # Perform chosen clustering and plot results
        if alg_name == "KMeans":
            alg = KMeans(n_clusters=number_clusters)
            alg.fit(data_set)
            cluster_labels = alg.fit_predict(data_set)

            self.simple_cluster_plot(alg, alg_name, cluster_labels, number_clusters, show_centroids, data_set)
        else:
            bandwidth = estimate_bandwidth(data_set, quantile=0.2)
            alg = MeanShift(bandwidth=bandwidth)
            alg.fit(data_set)
            cluster_labels = alg.fit_predict(data_set)
            number_clusters = len(np.unique(cluster_labels))
            self.simple_cluster_plot(alg, alg_name, cluster_labels, number_clusters, show_centroids, data_set)

        # Plot color and silhouette plots with results from clustering
        self.color_map_plot(alg, number_clusters, show_centroids, data_set)
        self.silhouette_plot(cluster_labels, number_clusters, data_set)

        # Update canvas UI to show plots
        self.canvas.draw()

    # Perform 2d PCA and plot 
    def do_pca_and_plot(self, data):
        pca = PCA(n_components=2)
        pca.fit(data[1:])
        data_set = pca.transform(data[1:])
        # add new subplot to figure, 2x2 grid, 1st position
        ax = self.figure.add_subplot(221)
        ax.scatter(data_set[:, 0], data_set[:, 1])
        return data_set

    # Perform 2d NMF and plot
    def do_nmf_and_plot(self, data):
        nmf = NMF(n_components=2)
        nmf.fit(data[1:])
        data_set = nmf.transform(data[1:])
        # add new subplot to figure, 2x2 grid, 1st position
        ax = self.figure.add_subplot(221)
        ax.scatter(data_set[:, 0], data_set[:, 1])
        return data_set

        
    def silhouette_plot(self, cluster_labels, no_clusters, data_set):
        # add new subplot to figure, 2x2 grid, 4th position
        ax1 = self.figure.add_subplot(224)
        
        # set x limits
        ax1.set_xlim([-1, 1])
        
        # Set y limits
        ax1.set_ylim([0, len(data_set) + (no_clusters + 1) * 5])
        
        # Calculate silhouette scores for dataset as a whole and individual rows
        score = silhouette_score(data_set, cluster_labels)
        sample_silhouette_values = silhouette_samples(data_set, cluster_labels)

        # Leave a gap at the bottom of the graph
        y_lower = 5
        
        # Repeat for every cluster
        for i in range(no_clusters):
            
            # Fetch the silhouette values which correspond to the current cluster
            silhouette_values = sample_silhouette_values[cluster_labels == i]

            # Sort in ascending order
            silhouette_values.sort()

            # Find how many samples are in the current  cluster
            size_cluster_i = silhouette_values.shape[0]
            
            # Calculate an upper value for the height of the plot
            y_upper = y_lower + size_cluster_i

            # Assign colour based on which cluster
            color = cm.spectral(float(i) / no_clusters)
            
            #Fill the graph between 0 and the calculated silhouette value for each sample
            ax1.fill_betweenx(np.arange(y_lower, y_upper),
                              0, silhouette_values,
                              facecolor=color, edgecolor=color, alpha=0.7)

            # Add label with the cluster number beside solid colour on graph
            ax1.text(-0.07, y_lower + 0.5 * size_cluster_i, str(i))

            # Increment y lower to add gap between plots for each cluster
            y_lower = y_upper + 5

        # Set titles and axis labels accordingly
        ax1.set_title("Silhouette Plot for " + str(no_clusters) + " Clusters")
        ax1.set_xlabel("Silhouette Coeeficient")
        ax1.set_ylabel("Cluster Number")

        # Display a dotted line at the average score
        ax1.axvline(x=score, color="red", linestyle="--")

        # Set x and y axis increments
        ax1.set_yticks(())
        ax1.set_xticks([-1.0, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
        
        # Display average silhouette score
        self.ui.silhouette_score_label.setText("Silhouette score: " + str(score))

        # update UI Thread
        QtCore.QCoreApplication.processEvents()

    def simple_cluster_plot(self, alg, alg_name, labels, no_clusters, include_centroids, data_set):
        # add new subplot to figure, 2x2 grid, 2nd position
        ax2 = self.figure.add_subplot(222)
        
        # Calculate upper and lower limits for plotting on the graph add a gap around the edge
        x_min = data_set[:, 0].min() - 5
        x_max = data_set[:, 0].max() + 5
        y_min = data_set[:, 1].min() - 1
        y_max = data_set[:, 1].max() + 1
        ax2.set_xlim(x_min, x_max)
        ax2.set_ylim(y_min, y_max)
        
        # Assign colour based on cluster label
        colors = cm.spectral(labels.astype(float) / no_clusters)

        # Scatter points and assign colours
        ax2.scatter(data_set[:, 0], data_set[:, 1], c=colors, lw=0, alpha=0.6)
        
        # Calculate position of cluster centers
        cluster_centers = alg.cluster_centers_
        
        # Plot cluster centers as white circles with numeric label of cluster number inside if the user has toggled this on
        if include_centroids:
            ax2.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                        marker='o', c="white", alpha=1, s=200)

            for i, c in enumerate(cluster_centers):
                ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)

         # Set titles and axis labels accordingly
        if alg_name == "KMeans":
            ax2.set_title("Simple KMeans Plot for " + str(no_clusters) + " Clusters")
        elif alg_name == "MeanShift":
            ax2.set_title("Simple MeanShift Plot. Estimated Clusters : " + str(no_clusters))
        

    def extract_features_to_csv(self, directory):
        # Set progress to 0
        self.ui.ExtractionProgress.setValue(0)
        # Update UI thread
        QtCore.QCoreApplication.processEvents()

        files = []
        # Open features and files csv files
        with open('features.csv', 'w') as csvfile:
            with open('files.csv', 'w') as filenames_csv:
                writer = csv.writer(csvfile, quoting=csv.QUOTE_NONE)
                file_writer = csv.writer(filenames_csv, quoting=csv.QUOTE_NONE)
                # Write feature headers
                field_names = ['Section1Entropy', 'Section2Entropy', 'Section3Entropy', 'Section4Entropy',
                               'FileEntropy', 'CodeDataRatio', 'MajorImageVersion', 'NumberOfSections', 'KERNEL32.DLL',
                               'USER32.DLL', 'ADVAPI32.dll', 'msvcrt.dll', 'GDI32.dll', 'SHELL32.dll', 'ole32.dll',
                               'WS2_32.dll', 'SHLWAPI.dll', 'COMCTL32.dll']
                writer.writerow(field_names)
                number_files = 0

                # Count number of files
                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        number_files += 1
                # Repeat for each eligble file in directory
                for filename in os.listdir(directory):
                    if filename.endswith(".dll") or filename.endswith('.exe'):
                        # Add name to list of files
                        files.append(filename)
                        
                        # Update UI label
                        self.ui.FileExtractionLabel.setText("Extracting features from: " + filename)
                        # Update Ui thread
                        QtCore.QCoreApplication.processEvents()
                        
                        # Open file as buffered reader
                        with open(directory + '/' + filename, "rb") as bufferedReader:
                            # Create instance of PE32 class
                            pe_file = PE32()
                            # Initialise PE32 object with current open file
                            pe_file.File(bufferedReader, filename, directory)
                            # Pass this object to helper method in PEUtil to extract chosen features
                            row = perform_feature_extraction(pe_file)
                            # Write extracted features to csv
                            writer.writerow(row)
                            # Update progress accordingly
                            value = self.ui.ExtractionProgress.value() + round(1000 / float(number_files))

                            # Prevent overflow on progress bar
                            if value > 1000:
                                self.ui.ExtractionProgress.setValue(1000)
                            else:
                                self.ui.ExtractionProgress.setValue(value)
                            
                # Write filenames to csv row
                file_writer.writerow(files)
            # Once complete ensure progress bar is full
            self.ui.ExtractionProgress.setValue(1000)
            # Update label to let user know extraction is complete
            self.ui.FileExtractionLabel.setText("Feature Extraction Complete")
            # Update UI thread
            QtCore.QCoreApplication.processEvents()

    def color_map_plot(self, cluster_alg, no_clusters, include_centroids, data_set):
         # add new subplot to figure, 2x2 grid, 3rd position
        ax = self.figure.add_subplot(223)

        # Find x and y minimum and maximum values. This is used in the generation of step values for the grid
        x_min = data_set[:, 0].min() - 5
        x_max = data_set[:, 0].max() + 5
        y_min = data_set[:, 1].min() - 1
        y_max = data_set[:, 1].max() + 1

        step_size = .01

        # Generate step values
        x_step_values = np.arange(x_min, x_max, step_size)
        y_step_values = np.arange(y_min, y_max, step_size)

        # Create grid from step values
        x_grid_values, y_grid_values = np.meshgrid(x_step_values, y_step_values)

        # Label each point on the grid
        labels = cluster_alg.predict(np.c_[x_grid_values.ravel(), y_grid_values.ravel()])

        # Plot each point of the grid, assigning a color based on where it is is in relation to discriminant lines
        labels = labels.reshape(x_grid_values.shape)
        ax.imshow(labels, interpolation='nearest',
                  extent=(x_grid_values.min(), x_grid_values.max(), y_grid_values.min(), y_grid_values.max()),
                  cmap='RdYlGn',
                  aspect='auto', origin='lower')

        # Plot 2d features on graph, with a black marker
        ax.plot(data_set[:, 0], data_set[:, 1], 'k.', markersize=8)

        # Plot cluster centers as white circles with numeric label of cluster number inside if the user has toggled this on
        cluster_centers = cluster_alg.cluster_centers_
        if include_centroids:
            ax.scatter(cluster_centers[:, 0], cluster_centers[:, 1],
                       marker='o', c="white", alpha=1, s=200, zorder=19)

            for i, c in enumerate(cluster_centers):
                ax.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50, zorder=20)

        # Set titles and axis labels accordingly
        ax.set_title("Color Map Plot for " + str(no_clusters) + " Clusters")
        
        # Set x and y axis limits
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)
        
        # Remove increments from both axes
        ax.set_xticks(())
        ax.set_yticks(())

    def elbow(self):
        # Clear current figure
        self.elbow_figure.clf()
        
        # Read features from csv
        data = read_csv_to_numpy_array()
        
        # Get number of components to use from UI spinner
        components = self.ui.components_spinner_elbow.value()
        
        
        # Repeat for both PCA and NMF
        for decomposition_algorithm in ["PCA", "NMF"]:
            elbow_scores = []

            # Set values to loop between from UI spinners
            min_ = self.ui.min_cluster_spin_box_elbow.value()
            max_ = self.ui.max_cluster_spin_box_elbow.value()
            
            # Perform chosen decomposition
            if decomposition_algorithm == "PCA":
                data_set = do_pca(data, components)
                position = 1
            elif decomposition_algorithm == "NMF":
                data_set = do_nmf(data, components)
                position = 2
            
            # Calcluate increments between min_ and max_ for plotting x axis
            number_clusters = range(min_, max_ + 1, 1)
    
            # Perform KMeans clustering with specified number of clusters
            while min_ <= max_:
                km = KMeans(n_clusters=min_)
                # Calculate elbow 'score' or cost function and append to list for plotting on y axis
                elbow_scores.append(abs(km.fit(data_set).score(data_set)))
                min_ += 1
    
            # Add new sup plot to figure, 1x2 grid, PCA plot in first position, NMF plot in second position
            ax = self.elbow_figure.add_subplot(1,2,position)
            print(number_clusters)
            ax.plot(number_clusters, elbow_scores)
            
            # Set titles and axis labels accordingly
            ax.set_title("KMeans Elbow Plot for "+decomposition_algorithm+" Decomposition")
            ax.set_ylabel("Cost Funtion of K")
            ax.set_xlabel("Number of Clusters")
        
        # Update UI to show plots
        self.elbow_canvas.draw()

# Entry point for program
app = QApplication(sys.argv)
ex = PEMachineLearning()
sys.exit(app.exec_())
